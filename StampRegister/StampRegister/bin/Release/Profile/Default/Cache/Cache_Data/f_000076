{"version":3,"file":"js/chunk-common-ff7ee345.4f12a351.js","mappings":"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","sources":["webpack://@creators/cms-next/./src/api/emoji-images.js","webpack://@creators/cms-next/./src/api/emoji.js","webpack://@creators/cms-next/./src/api/sticker.js","webpack://@creators/cms-next/./src/api/theme.js"],"sourcesContent":["/** EmojiImage model\n * @module EmojiImageModel\n */\nimport doFetch from '../models/do-fetch';\n\nimport { CUSTOM_NUM_START_FROM, packageSortingFn } from './emoji';\n\nexport function transformTypeToString(type) {\n    let res = type.toString();\n    while (res.length < 3) {\n        res = `0${res}`;\n    }\n    return res;\n}\n\n// remove base64 mime meta,\n// ie everything before \",\"\nexport function removeBase64Prefix(content) {\n    const afterExecRegexp = /,(.+)/.exec(content);\n    if (afterExecRegexp && afterExecRegexp.length > 1) {\n        content = afterExecRegexp[1];\n    }\n    return content;\n}\n\nexport const EmojiImageModel = {\n    getAll: id => doFetch('GET', `api/emoji/${id}/image/`),\n    get: (id, type) => doFetch('GET', `emoji/${id}/image/${type}`),\n\n    /**\n     * Response of emoji image\n     * @typedef ImageResponse\n     * @type {Object}\n     * @property {String} type\n     * @property {Int} height\n     * @property {Int} width\n     * @property {Int} mainPosition\n     * @property {String} url\n     */\n\n    /**\n     * upload an image for a emoji\n     * @param {String} id id of an emoji\n     * @param {Object} data\n     * @param {String} data.content base64 content of the file\n     * @param {String} data.type Identify the image type in inside its emoji package.\n     *                           pattern: tab or ^([\\d]{3})$\n     * @returns {ImageResponse}\n     */\n    upload: (id, data) => {\n        const { content, type } = data;\n        if (!id || !content || !type) {\n            return Promise.reject(\n                new Error(\n                    'emoji id, image content and type must given to upload an image',\n                ),\n            );\n        }\n        data.content = removeBase64Prefix(data.content);\n        return doFetch('PUT', `api/emoji/${id}/image/`, { data });\n    },\n\n    /**\n     * Info represents main image of a emoji\n     * @typedef MainImageInfo\n     * @type {Object}\n     * @property {Int} mainPosition\n     * @property {String} type\n     */\n\n    /**\n     * Error of main image\n     * @typedef MainImageError\n     * @type {Object}\n     * @property {Int} mainPosition\n     * @property {String} error error message\n     */\n\n    /**\n     * Response of update image main selection api\n     * @typedef UpdateImageMainSelectionResponse\n     * @type {Object}\n     * @property {Array.<MainImageInfo>} mainImages an array of main image which is okay\n     * @property {Array.<MainImageError>} errors an array of not okay main images\n     */\n\n    /**\n     * update image main position\n     * @param {String} id emoji id\n     * @param {Object} data data to put\n     * @param {Array.<MainImageInfo>} data.images array of types and the associated main position\n     * @returns {UpdateImageMainSelectionResponse}\n     */\n    updateImageMainSelection: (id, data) => {\n        const keys = ['type'];\n        const requestData = data.map((mainImage = {}, i) => {\n            const res = {\n                mainPosition: i + 1,\n            };\n            keys.forEach(key => (res[key] = mainImage[key]));\n            return res;\n        });\n        return doFetch('PUT', `api/emoji/${id}/image/main_selection`, {\n            data: requestData,\n        });\n    },\n\n    /**\n     * Add an image section\n     * @returns {ImageResponse}\n     */\n    create: id => doFetch('POST', `api/emoji/${id}/image/`),\n\n    /**\n     * remove an image\n     * @param {String} id emoji id\n     * @param {Object} data data for DELETE\n     * @param {String} data.supressType either 'emoji_image' or 'content_only'\n     *                                  'emoji_image' should only be used on original emoji\n     * @param {String} data.type type of the image\n     * @returns {undefined}\n     */\n    remove: (id, data) => {\n        const { type, supressType } = data;\n        return doFetch('DELETE', `api/emoji/${id}/image/${type}`, {\n            params: {\n                supressType,\n            },\n        });\n    },\n\n    /**\n     * remove all images of an emoji\n     */\n    removeAll: id => doFetch('DELETE', `api/emoji/${id}/image/`),\n\n    /**\n     * Determine whethere the specified image in package is a custom emoji.\n     * @param {Object} packageType packageType returned from server\n     * @param {<ImageResponse>} image emojiImage\n     */\n    isCustomEmoji(packageType, image) {\n        return (\n            image.type !== 'tab' &&\n            CUSTOM_NUM_START_FROM[packageType] !== undefined &&\n            image.type >= CUSTOM_NUM_START_FROM[packageType]\n        );\n    },\n\n    uploadZipFile(id, file) {\n        return doFetch('POST', `api/emoji/${id}/image/upload_zip`, {\n            data: {\n                zip: file,\n            },\n        }).then(res => {\n            res.uploaded = Object.keys(res.uploaded)\n                .map(key => {\n                    return res.uploaded[key];\n                })\n                .sort(packageSortingFn);\n            // in case an error is bigger than package's lowest image count\n            res.imageError = res.imageError || {};\n            res.imageError = Object.keys(res.imageError)\n                .map(key => {\n                    return {\n                        type: key,\n                        message: res.imageError[key],\n                    };\n                })\n                .sort(packageSortingFn);\n            return res;\n        });\n    },\n\n    updateCount(id, count) {\n        return doFetch('PUT', `api/emoji/${id}/image/count`, {\n            data: {\n                imageCount: count,\n            },\n        });\n    },\n};\n\nexport default EmojiImageModel;\n","/** Emoji model\n * @module EmojiModel\n */\nimport doFetch from '../models/do-fetch';\nimport { removeBase64Prefix } from './emoji-images';\n\nexport const CUSTOM_NUM_START_FROM = {\n    original: '001',\n    kana_original: '162',\n    romaji_original: '105',\n    kana_romaji_original: '266',\n};\nexport const CUSTOM_EMOJI_MIN_COUNT = 8;\n\nexport const LOWEST_PACKAGE_IMAGE_COUNT = {\n    original: CUSTOM_EMOJI_MIN_COUNT,\n    kana_original: 161 + CUSTOM_EMOJI_MIN_COUNT,\n    romaji_original: 104 + CUSTOM_EMOJI_MIN_COUNT,\n    kana_romaji_original: 265 + CUSTOM_EMOJI_MIN_COUNT,\n    kana: 161,\n    romaji: 104,\n    kana_romaji: 265,\n};\n\nconst PACKAGE_ORDER = {\n    original: 0,\n    kana_original: 2,\n    romaji_original: 3,\n    kana_romaji_original: 1,\n    kana_romaji: 4,\n    kana: 5,\n    romaji: 6,\n};\n\n// the order should be 'tab' and ascendant numbers\nexport function packageSortingFn(a, b) {\n    const keyA = a.type === 'tab' ? a.type : parseInt(a.type, 10);\n    const keyB = b.type === 'tab' ? b.type : parseInt(b.type, 10);\n    if (keyA < keyB || keyA === 'tab') {\n        return -1;\n    }\n    if (keyA > keyB || keyB === 'tab') {\n        return 1;\n    }\n    return 0;\n}\n\nexport default {\n    /**\n     * title and description for a languages\n     * @typedef Meta\n     * @type {Object}\n     * @prop {String} languageCode\n     * @prop {String} title\n     * @prop {String} description\n     */\n\n    /**\n     * emoji post data\n     * @typedef EmojiPostData\n     * @type {Object}\n     * @prop {Boolean} allArea Specifies whether this emoji is for sale in all areas.\n     * @prop {String} copyright copyright\n     * @prop {String} designUrl Url where design content can be verified\n     * @prop {Array.<Meta>} meta List of localized package meta informations\n     * @prop {String} packageTypeName package type description\n     * @prop {String} usePhoto Indicate if the package uses photographies\n     * @prop {Array.<String>} [areaCodes] List of selling area codes\n     * @prop {Object} [attachmentFile]\n     * @prop {String} attachmentFile.content base64 content of the file\n     * @prop {String} attachmentFile.name The name of the originally uploaded file\n     * @prop {String} [requestComment] User additionnal information about the review request\n     */\n\n    /**\n     * get all possible package type for emoji\n     */\n    getPackageType: () =>\n        doFetch('GET', 'api/emoji/package_type/').then(data => {\n            return data.sort((a, b) =>\n                PACKAGE_ORDER[a.name] < PACKAGE_ORDER[b.name]\n                    ? -1\n                    : PACKAGE_ORDER[a.name] > PACKAGE_ORDER[b.name]\n                    ? 1\n                    : 0,\n            );\n        }),\n\n    /**\n     * @typedef MetaValidateResult\n     * @type {Object}\n     * @prop {Boolean} isValid\n     * @prop {Array.<String>} reasons array of reasons it's failed,\n     * one of NGWORD, NOT_CONTAINS_URI, DUPLICATED, FRIENDLY_CHARACTERS\n     */\n\n    /**\n     * validate given information\n     * @param {String} columnName title or description\n     * @param {Object} data data to validate\n     * @param {String} data.langCode language code of meta\n     * @param {String} data.value The field value\n     * @param {String} emojiId emoji's id\n     * @return {MetaValidateResult}\n     */\n    validateMetaOrCopyright: (columnName, data) => {\n        if (!/^(title|description|copyright)$/.test(columnName)) {\n            // resolve same api as MetaValidateResult\n            return Promise.resolve({\n                isValid: false,\n                reasons: [\n                    'columnName can only be title, description or copyright',\n                ],\n            });\n        }\n        const { langCode, value, emojiId } = data;\n        const params = {\n            value,\n            column: langCode ? `meta[${langCode}][${columnName}]` : 'copyright',\n        };\n        if (emojiId) {\n            params.emojiId = emojiId;\n        }\n        return doFetch('GET', 'api/emoji/validate', { params }).then(res => {\n            let { success, errors = [] } = res;\n            errors = Array.isArray(errors) ? errors : [];\n            return {\n                isValid: success,\n                reasons: errors.map(e => e.type),\n            };\n        });\n    },\n\n    /**\n     * serialize state to postData\n     */\n    serialize: (state, config = {}) => {\n        function serializeMeta(meta = {}) {\n            return Object.keys(meta).map(key => {\n                const targetMeta = meta[key];\n                return {\n                    languageCode: key,\n                    description: targetMeta.description,\n                    title: targetMeta.title,\n                };\n            });\n        }\n\n        const data = {\n            allArea: state.allArea,\n            copyright: state.copyright,\n            designUrl: state.designUrl || null,\n            meta: config.useMetaHash ? state.meta : serializeMeta(state.meta),\n            emojiType: state.emojiType,\n            packageTypeName: state.pkgTypeName,\n            usePhoto: state.usePhoto,\n            requestComment: state.requestComment,\n            campaign: state.campaignId,\n            subscription: state.subscription,\n        };\n        if (state.areaCodes && state.areaCodes.length > 0) {\n            data.areaCodes = state.areaCodes;\n        }\n        if (state.attachment) {\n            data.attachmentFile = {\n                content: removeBase64Prefix(state.attachment.data),\n                name: state.attachment.fileName,\n            };\n        } else {\n            data.attachmentFile = null;\n        }\n        if (state.id) {\n            data.id = state.id;\n        }\n        return data;\n    },\n\n    /**\n     * create an emoji\n     * @param {EmojiPostData} data data to post\n     */\n    create: data => {\n        return doFetch('POST', 'api/emoji/', { data });\n    },\n\n    /**\n     * get an emoji\n     * @param {String} id target emoji id\n     */\n    get: (id, addAttributes) => {\n        const config = addAttributes\n            ? {\n                  params: {\n                      addAttributes,\n                  },\n              }\n            : {};\n        return doFetch('GET', `api/emoji/${id}`, config).then(res => {\n            try {\n                res.packageType.structure.sort(packageSortingFn);\n            } catch (err) {\n                // eslint-disable-next-line no-console\n                console.warn(err);\n            }\n            res.timestamp = Date.now();\n            return res;\n        });\n    },\n\n    /**\n     * get all emoji\n     * @param {Number} page number of page to fetch\n     * @param {Number} limit number of entries in a page\n     */\n    getAll: (page, limit) =>\n        doFetch('GET', 'api/emoji/', { params: { page, limit } }),\n\n    /**\n     * Update an emoji\n     * @param {EmojiPostData} data data to post\n     * @param {String} data.id target emoji id\n     */\n    update: data => doFetch('PUT', 'api/emoji/', { data }),\n\n    /**\n     * Delete an emoji\n     * @param {String} id target emoji id\n     */\n    delete: id => doFetch('DELETE', `api/emoji/${id}`),\n\n    /**\n     * Delete the update request from target emoji\n     * @param {String} id target emoji id\n     */\n    deleteUpdateRequest: id =>\n        doFetch('DELETE', `api/emoji/${id}/update_request/`),\n\n    /**\n     * Receive all available tier informations.\n     */\n    getCommonPriceTiers: () => doFetch('GET', 'api/emoji/tier/'),\n\n    /**\n     * Getting meta entry by language code.\n     * @param {Object} emoji emoji data entry\n     * @param {String} languageCode languageCode to get\n     */\n    getMeta: function (emoji, languageCode) {\n        if (!emoji.meta) {\n            return;\n        }\n        return (\n            emoji.meta.find(meta => meta.languageCode === languageCode) ||\n            emoji.meta.find(emoji.meta, meta => meta.languageCode === 'en') ||\n            emoji.meta[0]\n        );\n    },\n\n    /**\n     * Get all available price tiers for a specific Emoji.\n     * @param {String} id emoji's id\n     */\n    getAvailableTiers: id => doFetch('GET', `api/emoji/${id}/tier/`),\n\n    /**\n     * Set price tier for a specific Emoji.\n     * @param {String} id emoji's id\n     * @param {String} tier tier to set\n     */\n    savePriceTier: (id, tier) => doFetch('PUT', `api/emoji/${id}/tier/${tier}`),\n\n    getKeyword(image) {\n        return image.packageType !== 'original' && image.type !== image.keyword\n            ? image.keyword\n            : null;\n    },\n\n    getCustomNumberStartFrom(packageName) {\n        const target = CUSTOM_NUM_START_FROM[packageName];\n        return target ? parseInt(target, 10) : target;\n    },\n\n    getUpdateRequest: id => {\n        return doFetch('GET', `api/emoji/${id}/update_request/`).then(res => {\n            if (res.error || res.code === 404) {\n                return Promise.reject(res);\n            }\n            res.areaCodes = res.areas;\n            res.updateRequestId = res.id;\n            res.id = res.emojiId;\n            return res;\n        });\n    },\n    createUpdateRequest: data => {\n        data.emoji_id = data.id;\n        data.areas = data.areaCodes;\n        delete data.areaCodes;\n        // Avoid decamelize of language code\n        let dataAsIs = {\n            meta: data.meta,\n        };\n        return doFetch('POST', `api/emoji/${data.id}/update_request/`, {\n            data,\n            dataAsIs,\n        });\n    },\n    updateUpdateRequest: data => {\n        data.emoji_id = data.id;\n        delete data.id;\n        data.areas = data.areaCodes;\n        delete data.areaCodes;\n        delete data.packageTypeName;\n        delete data.usePhoto;\n        // Avoid decamelize of language code\n        let dataAsIs = {\n            meta: data.meta,\n        };\n        return doFetch('PUT', `api/emoji/${data.emoji_id}/update_request/`, {\n            data,\n            dataAsIs,\n        });\n    },\n};\n","import omit from 'lodash/omit';\nimport doFetch from '../models/do-fetch';\n\nconst ENDPOINT_PREFIX = 'sticker';\nconst API_PREFIX = 'api/sticker';\n\nexport default {\n    /**\n     * @typedef StickerPostData\n     * @type {Object}\n     * @prop {String} id sticker id\n     * @prop {String} fileId attachment id\n     */\n\n    /**\n     * create a sticker\n     * @param {StickerPostData} data request payload\n     */\n    create: data => {\n        const { meta } = data;\n        return doFetch('POST', `${ENDPOINT_PREFIX}/create`, {\n            data: omit(data, 'meta'),\n            dataAsIs: { meta },\n            headers: {\n                Accept: 'application/json',\n            },\n            contentType: 'multipart/form-data',\n        });\n    },\n\n    /**\n     * Update a sticker\n     * @param {StickerPostData} data request payload\n     */\n    update: data => {\n        const { id } = data;\n        const { meta } = data;\n        return doFetch('POST', `${ENDPOINT_PREFIX}/${id}/update`, {\n            data: omit(data, 'meta'),\n            dataAsIs: { meta },\n            headers: {\n                Accept: 'application/json',\n            },\n            contentType: 'multipart/form-data',\n            observe: 'response',\n        });\n    },\n\n    saveUpdateRequest: data => {\n        const { id } = data;\n        const { meta } = data;\n        return doFetch('POST', `${ENDPOINT_PREFIX}/${id}/save_update_request`, {\n            data: omit(data, 'meta'),\n            dataAsIs: { meta },\n            headers: {\n                Accept: 'application/json',\n            },\n            contentType: 'multipart/form-data',\n            observe: 'response',\n        });\n    },\n\n    /**\n     * get a sticker\n     * @param {String} id target sticker id\n     */\n    get: id => {\n        return doFetch('GET', `${API_PREFIX}/${id}/detail`, {\n            camelizeIgnore: ['meta', 'update_request'],\n        });\n    },\n\n    /**\n     * get all emoji\n     * @param {Number} page number of page to fetch\n     */\n    getAll: page => doFetch('GET', 'api/sticker/list', { params: { page } }),\n\n    /**\n     * remove attachment from target sticker\n     * @param {StickerPostData} data request payload\n     */\n    removeAttachment(data) {\n        const { id, fileId } = data;\n        return doFetch('POST', `${API_PREFIX}/${id}/remove_attachment`, {\n            data: { stickerAttachmentFileId: fileId },\n        });\n    },\n\n    /**\n     * Receive all available tier informations.\n     */\n    getCommonPriceTiers: () => doFetch('GET', 'api/sticker/tier'),\n\n    fetchPriceTiers(id) {\n        return doFetch('GET', `${API_PREFIX}/${id}/available_price_tiers`);\n    },\n\n    savePriceTier(id, tier) {\n        return doFetch('POST', `${API_PREFIX}/${id}/price?tier=${tier}`);\n    },\n\n    /**\n     * @typedef MetaValidateResult\n     * @type {Object}\n     * @prop {Boolean} isValid\n     * @prop {Array.<String>} reasons array of reasons it's failed,\n     * one of NGWORD, NOT_CONTAINS_URI, DUPLICATED, FRIENDLY_CHARACTERS\n     */\n\n    /**\n     * Validate given data\n     * @param {String} columnName title or description\n     * @param {Object} data data to validate\n     * @param {String} data.langCode language code of meta\n     * @param {String} data.value The field value\n     * @param {String} stickerId sticker id\n     * @return {MetaValidateResult}\n     */\n    validateFieldValue: (columnName, data) => {\n        if (\n            !['title', 'description', 'copyright', 'name'].includes(columnName)\n        ) {\n            return Promise.resolve({\n                isValid: false,\n                reasons: [\n                    'columnName can only be title, description, copyright, or name',\n                ],\n            });\n        }\n        const { stickerId, langCode, value } = data;\n        const column = ['title', 'description'].includes(columnName)\n            ? `meta[${langCode}][${columnName}]`\n            : columnName;\n\n        const params = {\n            value,\n            column,\n        };\n        if (columnName === 'title') {\n            params.title_duplication_check = 1;\n        }\n        if (stickerId) {\n            params.stickerId = stickerId;\n        }\n        return doFetch('GET', `${API_PREFIX}/validate`, { params }).then(\n            res => {\n                let { success, errors = [] } = res;\n                errors = Array.isArray(errors) ? errors : [];\n                return {\n                    isValid: success,\n                    reasons: errors.map(e => e.type),\n                };\n            },\n        );\n    },\n};\n","import omit from 'lodash/omit';\nimport { doFetch, camelizeData } from '../models/do-fetch';\n\nconst ENDPOINT_PREFIX = 'theme';\nconst API_PREFIX = 'api/theme';\n\nexport default {\n    /**\n     * @typedef ProductDetailPayload\n     * @type {Object}\n     * @prop {String} [id] Product id\n     */\n\n    /**\n     * @typedef RemoveAttachmentPayload\n     * @type {Object}\n     * @prop {String} [id] Product id\n     * @prop {String} fileId Attachment id\n     */\n\n    /**\n     * @param {ProductDetailPayload} data\n     */\n    create: data => {\n        const { meta } = data;\n        return doFetch('POST', `${ENDPOINT_PREFIX}/create`, {\n            data: omit(data, 'meta'),\n            dataAsIs: { meta },\n            headers: {\n                Accept: 'application/json',\n            },\n            contentType: 'multipart/form-data',\n        });\n    },\n\n    /**\n     * @param {ProductDetailPayload} data\n     */\n    update: data => {\n        const { id } = data;\n        const { meta } = data;\n        return doFetch('POST', `${ENDPOINT_PREFIX}/${id}/update`, {\n            data: omit(data, 'meta'),\n            dataAsIs: { meta },\n            headers: {\n                Accept: 'application/json',\n            },\n            contentType: 'multipart/form-data',\n            observe: 'response',\n        });\n    },\n\n    /**\n     * @param {ProductDetailPayload} data\n     */\n    saveUpdateRequest: data => {\n        const { id } = data;\n        const { meta } = data;\n        return doFetch('POST', `${ENDPOINT_PREFIX}/${id}/save_update_request`, {\n            data: omit(data, 'meta'),\n            dataAsIs: { meta },\n            headers: {\n                Accept: 'application/json',\n            },\n            contentType: 'multipart/form-data',\n            observe: 'response',\n        });\n    },\n\n    /**\n     * @param {String} id Product id\n     */\n    get: id => {\n        return doFetch('GET', `${API_PREFIX}/${id}/detail`, {\n            camelizeIgnore: ['meta', 'color_skin', 'update_request'],\n        }).then(theme => {\n            const {\n                tierId,\n                pendingTierId,\n                color_skin: colorSkin,\n                update_request: updateRequest,\n            } = theme;\n            delete theme['color_skin'];\n            delete theme['update_request'];\n\n            if (updateRequest) {\n                const colorSkin = updateRequest['color_skin'];\n                delete updateRequest['color_skin'];\n\n                Object.assign(theme, {\n                    updateRequest: {\n                        ...camelizeData(updateRequest, ['meta']),\n                        colorSkin,\n                    },\n                });\n            }\n\n            return {\n                ...theme,\n                colorSkin,\n                tierId: tierId ? Number(tierId) : null,\n                pendingTierId: pendingTierId ? Number(pendingTierId) : null,\n                timestamp: Date.now(),\n            };\n        });\n    },\n\n    /**\n     * @param {RemoveAttachmentPayload} data\n     */\n    removeAttachment(data) {\n        const { id, fileId } = data;\n        return doFetch('POST', `${API_PREFIX}/${id}/remove_attachment`, {\n            data: { themeAttachmentFileId: fileId },\n        });\n    },\n\n    savePriceTier(id, tier) {\n        return doFetch('POST', `${API_PREFIX}/${id}/price?tier=${tier}`);\n    },\n\n    fetchPriceTiers(id) {\n        return doFetch('GET', `${API_PREFIX}/${id}/available_price_tiers`);\n    },\n\n    /**\n     * @typedef MetaValidateResult\n     * @type {Object}\n     * @prop {Boolean} isValid\n     * @prop {Array.<String>} reasons Failed reasons. One of `NGWORD`, `NOT_CONTAINS_URI`, `DUPLICATED`, `FRIENDLY_CHARACTERS`\n     */\n\n    /**\n     * @param {String} columnName Can be `title`, `description`, or `copyright`\n     * @param {Object} data\n     * @param {String} data.langCode Language code of meta\n     * @param {String} data.value The field value\n     * @param {String} [data.themeId] Theme id\n     * @return {MetaValidateResult}\n     */\n    validateFieldValue: (columnName, data) => {\n        if (!['title', 'description', 'copyright'].includes(columnName)) {\n            return Promise.resolve({\n                isValid: false,\n                reasons: [\n                    `The 'columnName' can only be 'title', 'description' or 'copyright'`,\n                ],\n            });\n        }\n        const { themeId, langCode, value } = data;\n        const params = {\n            value,\n            column: langCode ? `meta[${langCode}][${columnName}]` : 'copyright',\n        };\n        if (columnName === 'title') {\n            params.titleDuplicationCheck = 1;\n        }\n        if (themeId) {\n            params.themeId = themeId;\n        }\n        return doFetch('GET', `${API_PREFIX}/validate`, { params }).then(\n            res => {\n                let { success, errors = [] } = res;\n                errors = Array.isArray(errors) ? errors : [];\n                return {\n                    isValid: success,\n                    reasons: errors.map(e => e.type),\n                };\n            },\n        );\n    },\n};\n"],"names":["removeBase64Prefix","content","afterExecRegexp","exec","length","EmojiImageModel","getAll","id","doFetch","get","type","upload","data","Promise","reject","Error","updateImageMainSelection","keys","requestData","map","mainImage","i","res","mainPosition","forEach","key","create","remove","supressType","params","removeAll","isCustomEmoji","packageType","image","undefined","CUSTOM_NUM_START_FROM","uploadZipFile","file","zip","then","uploaded","Object","sort","packageSortingFn","imageError","message","updateCount","count","imageCount","original","kana_original","romaji_original","kana_romaji_original","CUSTOM_EMOJI_MIN_COUNT","PACKAGE_ORDER","kana_romaji","kana","romaji","a","b","keyA","parseInt","keyB","getPackageType","name","validateMetaOrCopyright","columnName","test","resolve","isValid","reasons","langCode","value","emojiId","column","success","errors","Array","isArray","e","serialize","state","config","serializeMeta","meta","targetMeta","languageCode","description","title","allArea","copyright","designUrl","useMetaHash","emojiType","packageTypeName","pkgTypeName","usePhoto","requestComment","campaign","campaignId","subscription","areaCodes","attachment","attachmentFile","fileName","addAttributes","structure","err","console","warn","timestamp","Date","now","page","limit","update","delete","deleteUpdateRequest","getCommonPriceTiers","getMeta","emoji","find","getAvailableTiers","savePriceTier","tier","getKeyword","keyword","getCustomNumberStartFrom","packageName","target","getUpdateRequest","error","code","areas","updateRequestId","createUpdateRequest","emoji_id","dataAsIs","updateUpdateRequest","ENDPOINT_PREFIX","API_PREFIX","omit","headers","Accept","contentType","observe","saveUpdateRequest","camelizeIgnore","removeAttachment","fileId","stickerAttachmentFileId","fetchPriceTiers","validateFieldValue","includes","stickerId","title_duplication_check","theme","tierId","pendingTierId","color_skin","colorSkin","update_request","updateRequest","assign","camelizeData","Number","themeAttachmentFileId","themeId","titleDuplicationCheck"],"sourceRoot":""}